import os
import json
import aiofiles
import asyncio
from openai import AsyncOpenAI
from dotenv import load_dotenv


async def async_list_gen(list_data):
    """
    Asynchronously generates items from a given list.

    Args:
        list_data (iterable): The iterable containing items to be generated.

    Yields:
        item: Each item from the input list.

    Returns:
        None
    """
    for item in list_data:
        yield item


def remove_duplication(text: str) -> str:
    """
    Removes the second half of the input text.

    Args:
        text (str): The input text.

    Returns:
        str: The first half of the input text.
    """
    text_length = len(text)
    half_length = text_length // 2
    return text[:half_length]


async def async_prompt_model(client: AsyncOpenAI,
                             messages: str,
                             model: str = "gpt-3.5-turbo") -> str:
    """
    Asynchronously prompts the specified language model with the given messages.

    Args:
        client (AsyncOpenAI): The OpenAI API client used to interact with the language model.
        messages (str): The messages to be sent to the language model.
        model (str, optional): The language model to use (default is "gpt-3.5-turbo").

    Returns:
        str: The response generated by the language model.
    """
    chat_completion = await client.chat.completions.create(
        messages=messages, model=model
    )

    response: str = chat_completion.choices[0].message.content

    return response


async def fix_typo_and_grammatical_errors(client: AsyncOpenAI, text: str) -> str:
    """
    Fixes typographical and grammatical errors in the given text using a language model.

    Args:
        client (AsyncOpenAI): The OpenAI API client used to interact with the language model.
        text (str): The text containing typographical and grammatical errors.

    Returns:
        str: The fixed text in JSON format as {"fixed_text": "..."}.
    """
    messages = [
        {
            "role": "system",
            "content": """
                You are an excellent editor, great at identifying grammatical and typographical errors and fixing them.
                You will be provided a text. Fix the grammatical and typographical errors. Provide the output in JSON format as follows: {"fixed_text": "..."}
            """
        },
        {
            "role": "user",
            "content": text
        }
    ]

    response: str = await async_prompt_model(client, messages)

    try:
        response: dict = json.loads(response)
        return response.get("fixed_text", "Error: No key 'fixed_text' in response")
    except Exception as e:
        return "Error: Could not parse response as JSON"
    

async def async_os_walk(path: str):
    """
    An asynchronous version of os.walk.

    Args:
        path (str): The root directory to start the walk.

    Yields:
        Tuple[str, List[str], List[str]]: Tuple containing the current directory, list of subdirectories, and list of filenames.
    """
    for root, dirs, files in await asyncio.to_thread(os.walk, path):
        yield root, dirs, files



async def process_ocr_file(client: AsyncOpenAI, file_path: str, processed_ocr_data: list) -> None:
    """
    Asynchronously process an OCR JSON file by eliminating duplication and fixing typos in the OCR results.

    Args:
        client (AsyncOpenAI): The OpenAI API client used to interact with the language model.
        file_path (str): The path to the OCR JSON file.
        processed_ocr_data (list): The list to store the processed OCR data.

    Returns:
        None: The function appends the processed data to the provided list.
    """
    async with aiofiles.open(file_path, 'r') as f:
        ocr_data = json.loads(await f.read())

    async for block_data in async_list_gen(ocr_data):
        block_type = block_data["block_type"]
        ocr_result = block_data["ocr_result"]
        # eliminate duplication and fix typo
        if block_type:
            ocr_result = remove_duplication(ocr_result)
            ocr_result = await fix_typo_and_grammatical_errors(client, ocr_result)
            block_data["ocr_result"] = ocr_result
            processed_ocr_data.append(block_data)


async def process_ocr_json( client: AsyncOpenAI,
                            ocr_output_root: str, 
                            processed_fn: str = "processed_aws_extract_ocr.json") -> None:
    """
    Asynchronously process OCR JSON files in a specified directory by eliminating duplication and fixing typos.

    Args:
        client (AsyncOpenAI): The OpenAI API client used to interact with the language model.
        ocr_output_root (str): The root directory containing OCR JSON files.
        processed_fn (str, optional): The filename for the processed OCR data (default is "processed_aws_extract_ocr.json").

    Returns:
        None: The function writes the processed data to a file but doesn't return anything.
    """
    

    async def process_directory(dirpath: str) -> None:
        """
        Asynchronously process OCR JSON files in a directory.

        Args:
            dirpath (str): The path to the directory.

        Returns:
            None: The function appends the processed data to the global list.
        """
        async for root, dirnames, _ in async_os_walk(dirpath):
            async for dir_name in async_list_gen(dirnames):
                processed_ocr_data = []

                fn = os.path.join(root, dir_name,"aws_extract_ocr.json")
                p_fn = os.path.join(root, dir_name, processed_fn)

                # process file
                await process_ocr_file(client, fn, processed_ocr_data)
                
                # save processed data in new file
                async with aiofiles.open(p_fn, 'w') as file:
                    await file.write(json.dumps(processed_ocr_data, indent=2))
                    print(f"Processed data written to: {p_fn}")

    await process_directory(ocr_output_root)


if __name__ == "__main__":
    month_and_year = "december_1994"
    ocr_output_root = os.path.join("data","ocr_output", month_and_year)
    load_dotenv(dotenv_path="/home/temmie/code-and-scripts/playground/.env")
    client = AsyncOpenAI(api_key=os.environ.get("OPENAI_API_KEY"))
    asyncio.run(process_ocr_json(client, ocr_output_root))
